{"version":3,"sources":["webpack:///./src/components/calendar/EventFilter.jsx","webpack:///./src/components/calendar/CalendarViewToggle.jsx","webpack:///./src/templates/event-info.jsx","webpack:///./src/util/filters.js","webpack:///./src/components/Panel.jsx","webpack:///./src/components/calendar/EventType.js","webpack:///./src/components/calendar/Upcoming.jsx","webpack:///./src/templates/upcoming-events.jsx","webpack:///./src/components/calendar/getEventList.js"],"names":["EnabledFilterTag","name","remove","className","onClick","DisabledFilterTag","add","EventFilterBlock","filterProps","withDivider","Fragment","EventFilterTags","allFilters","activeFilters","addFilter","removeFilter","clearFilters","tags","filter","includes","push","key","filterEvents","events","eventFilters","event","every","eventType","frontmatter","eventTypes","CalendarViewToggle","view","map","modifier","to","EventTypeList","EventInfo","image","slug","content","contentComponent","Consumer","value","EventInfoWithContext","isPreview","BodyComponent","HTMLContent","href","slice","download","imageInfo","src","_","get","alt","generateEventSubtitle","data","isMobile","dateTimeRange","markdownRemark","startDate","Date","startDateTime","endDate","endDateTime","bothCurrentYear","areCurrentYear","start","toDateTimeString","isShort","withYear","provideEnd","areSameDay","toLocaleTimeString","hour","minute","site","additionalPropsExtractor","subtitle","isNarrow","query","useFilters","filterList","useState","filters","setFilters","filterName","concat","PanelBlock","panelData","emptyText","isViewportWidthDesktop","getPanels","panel","idx","EmptyPanel","text","Panel","title","mobileSubtitle","excerpt","panelImage","PanelImage","panelHeader","PanelHeader","panelExcerpt","PanelExcerpt","length","el","i","eventTypeList","Upcoming","UpcomingWithContext","previewEventList","getEventList","isOnOrAfterDay","getEventPanelData","fields","UpcomingEvents","allMarkdownRemark","edges","tabTitle","isWide","nodes","sort","event1","event2","range1","range2","start1","start2","areSameMinute","end1"],"mappings":"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","file":"component---src-templates-upcoming-events-jsx-a8cc82dd7f1b8cdca278.js","sourcesContent":["import React from 'react'\nimport PropTypes from 'prop-types'\n\nconst EnabledFilterTag = ({name, remove}) => (\n    <a className=\"tag is-primary is-light\" onClick={remove}>{name}</a>\n)\n\nEnabledFilterTag.propTypes = {\n    name: PropTypes.string,\n    remove: PropTypes.func\n}\n\nconst DisabledFilterTag = ({name, add}) => (\n    <a className=\"tag\" onClick={add}>{name}</a>\n)\n\nDisabledFilterTag.propTypes = {\n    name: PropTypes.string,\n    add: PropTypes.func\n}\n\nexport const EventFilterBlock = ({filterProps, withDivider}) => (\n    <React.Fragment>\n        <div className=\"filter-block\">\n            <EventFilterTags filterProps={filterProps} />\n        </div>\n        {withDivider ? <hr className=\"filter-block-divider\"/> : null}\n    </React.Fragment>\n)\n\nexport const EventFilterTags = ({filterProps: {allFilters, activeFilters, addFilter, removeFilter, clearFilters}}) => {\n    // Construct array of tag objects\n    let tags = []\n    for (const filter of allFilters) {\n        if (activeFilters.includes(filter)) {\n            tags.push(<EnabledFilterTag key={filter} name={filter} remove={removeFilter(filter)} />)\n        } else {\n            tags.push(<DisabledFilterTag key={filter} name={filter} add={addFilter(filter)} />)\n        }\n    }\n\n    return (\n        <span className=\"tags\">\n            <span className=\"tag is-white\">Filters: </span>\n            {tags}\n            <a className=\"tag is-delete\" onClick={clearFilters} />\n        </span>\n    )\n}\n\nEventFilterTags.propTypes = {\n    filterProps: PropTypes.shape({\n        allFilters: PropTypes.arrayOf(PropTypes.string),\n        activeFilters: PropTypes.arrayOf(PropTypes.string),\n        addFilter: PropTypes.func.isRequired,\n        removeFilter: PropTypes.func.isRequired,\n        clearFilters: PropTypes.func.isRequired\n    })\n}\n\nEventFilterBlock.propTypes = EventFilterTags.propTypes\n\n// Function to filter a list of events based on a list of types.\n// We return only events for whom all types in the filter are present.\nexport const filterEvents = (events, eventFilters) => {\n    return events.filter(event => eventFilters.every(eventType => event.frontmatter.eventTypes.includes(eventType)))\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { Link } from 'gatsby'\n\nimport { FaCalendar, FaListUl } from 'react-icons/fa'\n\nexport const CalendarViewToggle = ({view}) => (\n    <React.Fragment>\n        {['is-hidden-touch', 'is-hidden-desktop is-centered'].map(modifier => (\n            <div className={`tabs is-boxed ${modifier}`} key={modifier}>\n                <ul>\n                    <li className={view == 'calendar' ? 'is-active' : ''}>\n                        <Link to=\"/calendar\">\n                            <span className=\"icon is-small\"><FaCalendar /></span><h1>Calendar</h1>\n                        </Link>\n                    </li>\n                    <li className={view == 'upcoming' ? 'is-active' : ''}>\n                        <Link to=\"/events\">\n                            <span className=\"icon is-small\"><FaListUl /></span><h1>Events list</h1>\n                        </Link>\n                    </li>\n                </ul>\n            </div>\n        ))}\n    </React.Fragment>\n)\n\nCalendarViewToggle.propTypes = {\n    view: PropTypes.oneOf(['calendar', 'upcoming'])\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { graphql } from 'gatsby'\nimport _ from 'lodash'\n\nimport PreviewCompatibleImage from '../components/PreviewCompatibleImage'\nimport { HTMLContent } from '../components/Content'\nimport { site } from '../util/templating'\nimport { areSameDay, areCurrentYear, toDateTimeString } from '../util/dates'\nimport { PreviewContext } from '../util/context'\n\n\n\n// List of types shown near top of event\nconst EventTypeList = ({eventTypes}) => {\n    if (eventTypes) {\n        return (\n            <div className=\"tags\">\n                {eventTypes.map(eventType => <span key={eventType} className=\"tag\">{eventType}</span>)}\n            </div>\n        )\n    } else {\n        return null\n    }\n}\n\nEventTypeList.propTypes = {\n    eventTypes: PropTypes.arrayOf(PropTypes.string)\n}\n\n// used by website and CMS previews\nexport const EventInfo = ({image, slug, eventTypes, content, contentComponent}) => (\n    <PreviewContext.Consumer>\n        {value => <EventInfoWithContext isPreview={value} image={image} slug={slug}\n        eventTypes={eventTypes} content={content} contentComponent={contentComponent} />}\n    </PreviewContext.Consumer>\n)\n\nconst EventInfoWithContext = ({isPreview, image, slug, eventTypes, content, contentComponent}) => {\n    const BodyComponent = contentComponent || HTMLContent\n\n    return (\n        <React.Fragment>\n            <EventTypeList eventTypes={eventTypes} />\n            {!isPreview && slug ? (\n                <a className=\"button event-download-button\" href={`/ics${slug.slice(0, -1)}.ics`} download>\n                    Add to Calendar\n                </a>\n            ) : null}\n            <PreviewCompatibleImage imageInfo={image ? {src: _.get(image, 'srcNode.childImageSharp.fixedAspect.src', image.src),\n                                                        alt: image.alt} : null} />\n            <BodyComponent content={content} />\n        </React.Fragment>\n    )\n}\n\nEventInfoWithContext.propTypes = {\n    isPreview: PropTypes.bool,\n    eventTypes: EventTypeList.propTypes.eventTypes,\n    image: PropTypes.object.isRequired,\n    content: PropTypes.string.isRequired,\n    contentComponent: PropTypes.elementType\n}\n\nEventInfo.propTypes = EventInfoWithContext.propTypes\n\nexport const generateEventSubtitle = (data, isMobile=false) => {\n    const dateTimeRange = data.markdownRemark.frontmatter.dateTimeRange\n\n    const startDate = new Date(dateTimeRange.startDateTime)\n    const endDate = new Date(dateTimeRange.endDateTime)\n    \n    const bothCurrentYear = areCurrentYear(startDate, endDate)\n\n    const start = toDateTimeString(startDate, {isShort: isMobile, withYear: !bothCurrentYear})\n    \n    if (!dateTimeRange.provideEnd) {\n        return start\n    } else if (areSameDay(startDate, endDate)) {\n        return start + `–${endDate.toLocaleTimeString(\"en-GB\", {hour: \"2-digit\", minute: \"2-digit\"})}`\n    } else {\n        return start + ` – ${toDateTimeString(endDate, {isShort: isMobile, withYear: !bothCurrentYear})}`\n    }\n    // This allows for events to go on overnight / over multiple days\n}\n\nconst extractor = (data) => ({subtitle: generateEventSubtitle(data)})\n\nexport default site(EventInfo, { additionalPropsExtractor: extractor, isNarrow: true })\n\nexport const query = graphql`\nquery eventInfoTemplate($id: String!) {\n    markdownRemark(id: { eq: $id }) {\n        ...EventFragment\n    }\n    heroData: allMarkdownRemark(filter: {id: {eq: $id}}) {\n        ...HeroFragment\n    }\n}\n`","import { useState } from 'react'\n\nexport const useFilters = (filterList) => {\n    const [filters, setFilters] = useState([])\n\n    const addFilter = (filterName) => (\n        () => {setFilters(filters.concat(filterName))}\n    )\n\n    const removeFilter = (filterName) => (\n        () => {setFilters(filters.filter(name => name !== filterName))}\n    )\n\n    const clearFilters = () => {\n        setFilters([])\n    }\n\n    return {\n        allFilters: filterList,\n        activeFilters: filters,\n        addFilter: addFilter,\n        removeFilter: removeFilter,\n        clearFilters: clearFilters\n    }\n}\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport { Link } from 'gatsby'\nimport _ from 'lodash'\n\nimport PreviewCompatibleImage from './PreviewCompatibleImage'\nimport { HTMLContentSmall } from './Content'\n\n// Component used in News Archive, Upcoming Events & Calendar Day Modal\n// CSS classes use name \"xpanel\" to distinguish from Bulma panel class\nexport const PanelBlock = ({panelData, emptyText, isViewportWidthDesktop}) => (\n    <div className={`xpanel-block`}>\n        {\n            getPanels(panelData, emptyText).map((panel, idx) => (\n                <div key={idx} className={`xpanel-background ${isViewportWidthDesktop ? \"is-viewport-width\" : \"\"}`}>\n                    <section className = \"section section-root\">\n                        <div className=\"container wide-container\">\n                            {panel}\n                        </div>\n                    </section>\n                </div>\n            ))\n        }\n    </div>\n)\n\nconst EmptyPanel = ({text}) => {\n    return (\n        <div className=\"xpanel\">\n            {text}\n        </div>\n    )\n}\n\nexport const Panel = ({image, slug, title, subtitle, mobileSubtitle, excerpt}) => {\n\n    const panelImage = <PanelImage image={image} />\n    const panelHeader = <PanelHeader slug={slug}\n                                     title={title}\n                                     subtitle={subtitle}\n                                     mobileSubtitle={mobileSubtitle} />\n    const panelExcerpt = <PanelExcerpt excerpt={excerpt} />\n\n    return (\n        <div className=\"xpanel\">\n            <div className=\"xpanel-header\">\n                {panelHeader}\n            </div>\n            <div className=\"xpanel-image\">\n                {panelImage}\n            </div>\n            <div className=\"xpanel-excerpt\">\n                {panelExcerpt}\n            </div>\n        </div>\n    )\n}\n\nconst PanelImage = ({image}) => {\n    if (image) {\n        const imageInfo = {\n            alt: image.alt,\n            src: _.get(image, 'srcNode.childImageSharp.fixedAspect.src', image.src)\n        }\n        return <PreviewCompatibleImage imageInfo={imageInfo} />\n    }\n    else {\n        return null\n    }\n}\n\nconst PanelHeader = ({slug, title, subtitle, mobileSubtitle}) => (\n    <Link to={slug}>\n        <h2 className={`title is-4 upcoming-title`}><strong>{title}</strong></h2>\n        <h3 className={`subtitle is-6 upcoming-subtitle is-hidden-mobile`}><strong>{subtitle}</strong></h3>\n        <h3 className={`subtitle is-6 upcoming-subtitle is-hidden-tablet`}><strong>{mobileSubtitle || subtitle}</strong></h3>\n    </Link>\n)\n\nconst PanelExcerpt = ({excerpt}) => (\n    <HTMLContentSmall content={excerpt} />\n)\n\n\nconst getPanels = (panelData, emptyText) => {\n    if (panelData.length > 0) {\n        return panelData.map((el, i) => <Panel image={el.image}\n                                               slug={el.slug}\n                                               title={el.title}\n                                               subtitle={el.subtitle}\n                                               mobileSubtitle={el.mobileSubtitle}\n                                               excerpt={el.excerpt}\n                                               key={i} />)\n    }\n    return [<EmptyPanel key=\"1\" text={emptyText || \"\"} />]\n}\n\nPanelExcerpt.propTypes = { excerpt: PropTypes.string }\n\nPanelHeader.propTypes = {\n    slug: PropTypes.string,\n    title: PropTypes.string,\n    subtitle: PropTypes.string,\n    mobileSubtitle: PropTypes.string,\n}\n\nPanelImage.propTypes = { image: PropTypes.object }\n\nPanel.propTypes = {\n    image: PropTypes.object,\n    slug: PropTypes.string,\n    title: PropTypes.string,\n    subtitle: PropTypes.string,\n    mobileSubtitle: PropTypes.string,\n    excerpt: PropTypes.string,\n}\n\nEmptyPanel.propTypes = { text: PropTypes.string }\n\nPanelBlock.propTypes = {\n    panelData: PropTypes.arrayOf(PropTypes.object).isRequired,\n    emptyText: PropTypes.string,\n    isViewportWidthDesktop: PropTypes.bool\n}\n","// List of allowed event types.\n// IF YOU UPDATE THIS LIST MAKE SURE YOU ALSO UPDATE THE LIST IN static/admin/config.yml\n// THEY MUST ALWAYS BE IDENTICAL\nexport const eventTypeList = [\n    'Benefit gig',\n    'Meeting - Programming',\n    'Meeting - Finance',\n    'Band competition',\n    'Other',\n]\n","import React from 'react'\nimport PropTypes from 'prop-types'\n\nimport { PanelBlock } from '../Panel'\nimport { eventPropTypeValidator } from '../validators'\nimport { EventFilterBlock, filterEvents } from './EventFilter'\nimport { eventTypeList } from './EventType'\nimport { getEventList } from './getEventList'\nimport { PreviewContext } from '../../util/context'\nimport { useFilters } from '../../util/filters'\nimport { isOnOrAfterDay } from '../../util/dates'\nimport { generateEventSubtitle } from '../../templates/event-info'\n\n\nexport const Upcoming = ({events}) => (  // 'events' is only_ used if it is a preview, otherwise it uses a static query\n    <PreviewContext.Consumer>\n        {value => <UpcomingWithContext isPreview={value} previewEventList={events} />}\n    </PreviewContext.Consumer>\n)\n\nconst UpcomingWithContext = ({isPreview, previewEventList}) => {\n    const filterProps = useFilters(eventTypeList)\n\n    // Get list of events occurring today or later\n    let events = isPreview ? previewEventList : getEventList()\n    events = events.filter(event => isOnOrAfterDay(new Date(), new Date(event.frontmatter.dateTimeRange.provideEnd ? event.frontmatter.dateTimeRange.endDateTime : event.frontmatter.dateTimeRange.startDateTime)))\n\n    const maxItems = 5\n\n    // Construct array of event panel data\n    const panelData = filterEvents(events, filterProps.activeFilters).slice(0, maxItems).map(event => getEventPanelData(event))\n\n    const emptyText = \"No events match the selected filters.\"\n\n    return (\n        <React.Fragment>\n            <h1 className=\"title\">Upcoming Events</h1>\n            <div>\n                <EventFilterBlock filterProps={filterProps} withDivider={false} />\n                <PanelBlock panelData={panelData} emptyText={emptyText} isViewportWidthDesktop={true}/>\n            </div>\n        </React.Fragment>\n    )\n}\n\nexport const getEventPanelData = (event) => {\n    return {\n        image: event.frontmatter.image,\n        slug: event.fields.slug,\n        title: event.frontmatter.title,\n        subtitle: generateEventSubtitle({markdownRemark: event}, false),\n        mobileSubtitle: generateEventSubtitle({markdownRemark: event}, true),\n        excerpt: event.excerpt\n    }\n}\n\n\nUpcoming.propTypes = {\n    events: PropTypes.arrayOf(\n        PropTypes.shape({\n            node: eventPropTypeValidator\n        })\n    )\n}\n\nUpcomingWithContext.propTypes = {\n    isPreview: PropTypes.bool.isRequired,\n    previewEventList: Upcoming.propTypes.events\n}\n","import React from 'react'\nimport { graphql } from 'gatsby'\n\nimport { site } from '../util/templating'\nimport { Upcoming } from '../components/calendar/Upcoming'\nimport { CalendarViewToggle } from '../components/calendar/CalendarViewToggle'\n\nexport const UpcomingEvents = ({events}) => {\n  return (\n    <section>\n      <CalendarViewToggle view='upcoming' />\n      <Upcoming events={events} />\n    </section>\n  )\n}\n\nUpcomingEvents.propTypes = {\n  events: Upcoming.propTypes.events\n}\n\nconst extractor = (data) => ({events: data.allMarkdownRemark.edges, tabTitle: \"Upcoming Events\"})\n\nexport default site(UpcomingEvents, { additionalPropsExtractor: extractor, isWide: true })\n\nexport const query = graphql`\nquery upcomingEventsTemplate($id: String!) {\n  markdownRemark(id: { eq: $id }) {\n    html\n  }\n  allMarkdownRemark(filter: {frontmatter: {templateKey: {eq: \"event-info\"}}}, sort: {fields: frontmatter___dateTimeRange___startDateTime, order: ASC}) {\n    edges {\n      node {\n        ...EventFragment\n      }\n    }\n  }\n  heroData: allMarkdownRemark(filter: {id: {eq: $id}}) {\n    ...HeroFragment\n  }\n}\n`","import { useStaticQuery, graphql } from 'gatsby'\n\nimport { areSameMinute } from '../../util/dates'\n\nexport const getEventList = () => {\n  const { allMarkdownRemark } = useStaticQuery(graphql`\n  query eventList {\n      allMarkdownRemark(filter: {frontmatter: {templateKey: {eq: \"event-info\"}}}, sort: {fields: frontmatter___dateTimeRange___startDateTime, order: ASC}) {\n          nodes {\n              ...EventFragment\n          }\n      }\n  }\n  `)\n\n  // Already started by start time, but if two events start at the same time, we want to sort then by the end time (if provided).\n  const nodesSorted = allMarkdownRemark.nodes.sort((event1, event2) => {\n    const range1 = event1.frontmatter.dateTimeRange\n    const range2 = event2.frontmatter.dateTimeRange\n    const start1 = new Date(range1.startDateTime)\n    const start2 = new Date(range2.startDateTime)\n\n    // Only need to do anything if they start at the same time\n    if (areSameMinute(start1, start2)) {\n      // Four cases, for each combination of each providing or not providing an end time.\n      // We'll deal with them all.\n      if (range1.provideEnd) {\n        const end1 = new Date(range1.endDateTime)\n\n        if (range2.provideEnd) {\n          const end2 = new Date(range2.endDateTime)\n          // Both ends provided, so sort by end date\n          return end1 - end2\n        } else {\n          // Range 2 has no defined end time, so ends first\n          return 1\n        }\n      } else {\n        if (range2.provideEnd) {\n          // Range 1 has no defined end time, so ends first\n          return -1\n        } else {\n          // Neither have a defined end, so they occur at the same time\n          return 0\n        }\n      }\n    } else {\n      // Leave in current order\n      return 0\n    }\n  })\n\n  return nodesSorted\n}\n"],"sourceRoot":""}